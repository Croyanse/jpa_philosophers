
------------------------ thread gestion
int pthread_create (pthread_t * thread, pthread_attr_t * attr, void * (* start_routine) (void *), void * arg);
	1 =  l'identifiant du thread qui sera créé;
	2 = NULL;
	3 = onction à exécuter
	4 = représente un argument que l'on peut passer à la fonction

void pthread_exit (void * retval);
	pour arreter un thread

int pthread_join (pthread_t th, void ** thread_return);
	verifie si les thread sont achevé (met en pause le thread appelant)

 int pthread_detach(pthread_t th);
	place le thread th dans l'état détaché. Cela garantit que 
	les ressources mémoire consommées par th seront immédiatement 
	libérées lorsque l'exécution de th s'achèvera. 
	Cependant, cela empêche les autres threads de se 
	synchroniser sur la mort de th en utilisant pthread_join

PTHREAD_THREADS_MAX définit le nombre maximum de thread

-------------------------------- MUTEX

pthread_mutex_ini

static pthread_mutex_t n_mutex = PTHREAD_MUTEX_INITIALIZER;
	creation de mutex

int pthread_mutex_lock (pthread_mutex_t * mutex);
	lock mutex

int pthread_mutex_unlock (pthread_mutex_t * mutex);
	unlock mutex

int pthread_mutex_destro ()

--------------------- get time

int gettimeofday(struct timeval *tv, struct timezone *tz);
	recupere le temps actuel

	struct liée ====
struct timeval {
    time_t      tv_sec;  /* secondes */
    suseconds_t tv_usec; /* microsecondes */
};